\section{Proposed Solution}
\label{sec:proposedSolution}

% Free form, variable number of sections, technical details.
% But in general do not mix solution and discussions/possible variation let that for discussion

Wollok is a complete new tool based on the same fundamental ideas that were present in Ozono and LOOP. In particular:

\begin{itemize}
\item \textbf{Incremental concepts introduction}: references, objects, messages, polymorphism, classes, inheritance.
\item \textbf{General purpose}: meaning not tied to any specific domain (e.g.: robots)
\end{itemize}

Besides this we also tried to address some other concerns detected while using Ozono for several years. Here's a list of main cathegories or lines of work in which Wollok extends the previous work

\begin{itemize}
\item \textbf{Profundizar y pulir el highlighting the conceptos primarios y la
estratificacion de conceptos}.
	(ej: literales de objetos, literales de colecciones. Objetos no como un
	elemento de la IDE -Ozono: nueva referencia global-, sino como un elemnto del
	lenguaje. Evita referencias globales.)
\item \textbf{Introducción de nuevos elementos concretos que explicitan
conceptos ya existentes} (ej: 1- var/val, 2- la idea de hacer un effect system
power que detecte efecto de lado, y asi poner checkeos para resolver el problema de si un método es una 'orden' o una 'pregunta', 3- program/libreria/test, 4-override ).
\item \textbf{Unificar las fases del aprendizaje} (ej: objetos+clases: un solo
lenguaje, misma herramientas, poder reutilizar y hacer convivir)
\item \textbf{Proveer un entorno inteligente que}: por un lado, estructure en
forma más estricta/explícita la experiencia; y que, por el otro lado, permita una gran asistencia al estudiante/desarrollador (esto tiene muchos elementos: 1- desde content assist, 2-syntax coloring, 3- resaltado de errores (sintaxis y tipado) 4-navegación de código, 5-busqueda de referencias, 6-diagramas automáticos de clases, 7-hasta llegar un sistema de tipos que permita la detección temprana de errores, 8-reducir errores frustrantes: se cancela la edicion por tener 1 solo editor de metodo por ves (poder visualizar más que un sólo método simul), evitar errores de imagenes)
\item \textbf{Acercar la experiencia de aprendizaje a las prácticas
industriales}: (acá el palo de que la imagen sólo existe en smalltalk, y en la
industria nadie la usa. Atrás de eso, la idea de archivos, y poder compartir con SVC. Por último la idea de actualizarse a un lenguaje con influencia de lenguajes modernos como xtend, scala, ruby, etc.)
\end{itemize}

\subsection{Entorno Inteligente de Trabajo}
\label{subsec:proposedSolution-entornoInteligente}

\subsubsection{Visualización y Navegación}

// todo: 
\begin{itemize}
  \item syntax highlight
  \item outline
  \item hovering
  \item vista de problems 
  \item navigate: goto (F3, click), flechita para ir al método que sobrescribe.
  \item find references 
\end{itemize}

\subsubsection{Asistencia}

//todo: 
\begin{itemize}
  \item content assist
  \item quick fixes
  \item code templates (nuevo)
\end{itemize}

\subsubsection{Checkeos y validaciones}

Wollok provee numerosos checkeos y validaciones estáticas, a fin de que el
alumno pueda encontrar los problemas en su código de manera temprana.
Incluso a medida que va escribiendo su código.
Esto contribuye a que el alumno mantenga control completo de su
código, y evita la sensación de estar perdido.
 
Todos los checkeos y problemas
generados se muestran agrupados en una vista dedicada a tal fín (Problems).

\begin{itemize}
  \item \textbf{De sintaxis}: dados por el parser y lexer automáticamente.
  \item \textbf{De estilo}: para promover uniformidad y consistencia de código.
  Ejemplos:
  		\begin{itemize}
  			\item \textit{Nombres}: variables camelcase comenzando en minúscula,
  			nombres de clases camelcase iniciando mayúscula, packages en minúsculas, etc.
  			\item \textit{Orden y agrupamiento}: dentro de un objeto o clase, primero
  			se definen sus referencias internas, luego constructores y finalmente los métodos.
  			\item \textit{Separación de programas}: las clases sólo se pueden definir
  			en archivos de tipo \textit{librería}, no dentro de un \textit{program}.
  			\item \textit{Evitar referencias duplicadas}: no se puede definir una
  			referencia con nombre ya utilizado en alguna otra referencia del contexto (local, método,
  			clase/objeto, etc.). Ni tampoco si ya está definida en la superclase.
		\end{itemize}
  \item \textbf{De resolución de referencias}: para evitar referencias a
  variables inexistentes y, en la medida de lo posible (por ser de tipado
  implícito) de envío de mensajes. Ejemplos:
  		\begin{itemize}
		  \item \textit{Referencias inexistentes}: a variables locales, parámetros, o
		  internas (clase/objeto).
		  \item \textit{Constructores inexistentes}: evaluando existencia de la
		  clase, y compatibilidad en el número de paråmetros.
		  \item \textit{Envío de mensajes (a this)}: al ser a this se pueden realizar
		  checkeos por la existencia del método y compatibilidad de parámetros, incluso sin
		  involucrar al sistema de tipos.
		\end{itemize}
  \item \textbf{De uso de referencias}: para la detección de código
  	erroneo o bien desactualizado. Por ejemplo: warnings por referencias nunca
 	utilizadas, nunca asignadas, o utilización de variables en lugar de valores.
  \item \textbf{De estructura}: evitan por ejemplo inconsistencias en las
  estructuras creadas por el alumno. Por ejemplo, se checkea
  que un método marcado como \textit{override} efectivamente esté
  sobrescribiendo.
  \item \textbf{De tipos}: verifican compatibilidad de referencias en base a sus
  tipos. Por ejemplo ante envío de mensajes, o asignaciones de variables. Basado
  en el sistema de tipos.
\end{itemize}


